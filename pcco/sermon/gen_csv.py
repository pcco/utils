"""Utility to generate sermon csv by ingesting raw text data from sermon browser
wordpress database.

The raw input data can be generated by executing:
./scripts/export-sermon-data.sh on the wordpress host
"""

from argparse import ArgumentParser
from csv import QUOTE_MINIMAL, writer
import re
from phpserialize import loads


def _gen_html_audio_element_str(data_item):
    """Helper function that generates a html string representing an audio element."""
    audio_html_str = (
        data_item["audio"]
        if "audio" in data_item and data_item["audio"] and data_item["audio"] != "NULL"
        else None
    )
    # the url is hardcoded to OIF, we may want to make this configurable
    return (
        "<audio controls>"
        f'<source src="https://pccoakland.org/oif/wp-content/uploads/sermons/{audio_html_str}" '
        'type="audio/mpeg">Your browser does not support the audio element.'
        "</audio>"
        if audio_html_str
        else ""
    )


def _format_scripture_data(data_item):
    """Helper function that converts scripture data to a human readable string.
    Expected input is the serialized PHP string to be converted to a python dictionary.
    """
    result = []
    start_data = loads(
        bytes(data_item["start"], encoding="utf-8"),
        decode_strings=True,
        array_hook=dict,
    )
    end_data = loads(
        bytes(data_item["end"], encoding="utf-8"), decode_strings=True, array_hook=dict
    )

    if start_data and end_data:
        start_data_items = start_data.items()
        end_data_items = end_data.items()
        if len(start_data_items) != len(end_data_items):
            raise ValueError("Mismatch between number of start and end items")
        for idx, scripture_data in start_data_items:
            result.append(
                f"{scripture_data['book']} {scripture_data['chapter']}:{scripture_data['verse']}-{end_data[idx]['verse']}"
            )

    if result:
        return ",".join(result)


def _normalize(val):
    """Remove backslashes from strings"""
    result = re.sub(r"\\", "", str(val))
    return result if result else val


def read_raw_sermon_data(file):
    result = []
    with open(file, mode="r", errors="ignore") as f:
        lines = f.read().splitlines()
        data = [line.split("\t") for line in lines]
        header = data[0]
        rows = data[1:]
        for row in rows:
            result_item = {}
            for idx, header_item in enumerate(header):
                result_item[header_item] = _normalize(row[idx])
            result.append(result_item)
    return result


def generate_csv(out_csv, data):
    """Transform the data into a CSV table"""
    with open(out_csv, mode="w", encoding="utf8") as csv_file:
        csv_writer = writer(csv_file, quoting=QUOTE_MINIMAL, escapechar="\\")
        # Write header
        csv_writer.writerow(
            ["Date", "Speaker", "Title", "Scripture", "Series", "Audio"]
        )
        # Write rest of body
        for data_item in data:
            scripture_data = _format_scripture_data(data_item)
            audio_html_element = _gen_html_audio_element_str(data_item)
            csv_writer.writerow(
                [
                    data_item["datetime"],
                    data_item["preacher"],
                    data_item["title"],
                    scripture_data,
                    data_item["series"],
                    audio_html_element,
                ]
            )


def process_args():
    argparser = ArgumentParser()
    argparser.add_argument(
        "--input-sermon-file",
        "-i",
        action="store",
        required=True,
        help="The path of the input data file. \
             This input file can be generated via \
             the export-sermon-data.sh script.",
    )
    argparser.add_argument(
        "--output-csv-file",
        "-o",
        action="store",
        default="output.csv",
        help="The path of the output csv file, \
             defaults to output.csv to the current working directory",
    )
    return argparser.parse_args()


def main():
    args = process_args()
    data = read_raw_sermon_data(args.input_sermon_file)
    generate_csv(args.output_csv_file, data)


if __name__ == "__main__":
    main()
